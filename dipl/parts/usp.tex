\subsection{USP}

	In section~\ref{sec:prel} we have defined a timetable as a set of elementary connections. While do not pose any other restrictions on this set or on the elementary connections themselves, the real world timetables usually have a specific nature. Quite often are the connections repetitive, that is, the same sequence of elementary connections is repeated in several different moments throughout the day.
	
	Another thing we may notice is that if we talk about \textit{optimal} connections between a pair of distant cities $u$ and $v$, we are often left with a few possibilities as to \textit{which way should we go}. This is not only because the underlying graph is usually quite sparse~\footnote{Maybe with exception of the airline timetables, which tend to be more dense}, but also because for longer distances we generally need to make use of some express connection that stops only in (small number of) bigger cities.
	
	Thus the main idea which will repeat often throughout this section: \textit{when carrying out an optimal connection between a pair of cities, one often goes along the same path regardless of the starting time}. \\
	
	\noindent To formalize this idea, we will introduce the definition of an \textit{underlying shortest path} - a path in UG that corresponds to some optimal connection in the timetable. To do this, we will first define a function $path$ that extracts the \textbf{underlying path} (trajectory in the UG) from a given connection. Let $c$ be a connection $c = (e_{1}, e_{2}, ..., e_{k})$.
	
	\begin{equation*}
		\bm{path(c)} = shrink(from(e_{1}), from(e_{2}), ..., from(e_{k}), to(e_{k}))
	\end{equation*}
	
	\noindent Note, that if the connection involves waiting in a city (as e.g. in picture~\ref{fig:pathfunc}), $e_{x}^{i} = e_{x}^{i + 1}$ for some $i$. That is why we apply the $shrink$ function, which replaces any sub-sequences of the type $(z, z, ..., z)$ by $(z)$ in a sequence. This was rather technical way of expressing a simple intuition - for a given connection, the $path$ function simply outputs a sequence of visited cities. Now we can formalize the underlying shortest path.
	
	\begin{definition}
        \textbf{Underlying shortest path (USP)} \\
		A path $p = (v_{1}, v_{2}, ..., v_{k})$ in $UG_{T}$ is an \textbf{underlying shortest path} if and only if $\exists t \in \mathcal{N}: p = path(c_{(v_{1}, t, v_{k})}^{*}), c_{(v_{1}, t, v_{k})}^{*} \in C_{T}$
    \end{definition}
    
    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/pathfunc}
		\end{center}
		\caption{\label{fig:pathfunc} The $path$ function applied on a connection to get the underlying path}
	\end{figure}
	
	\noindent Please note that the terminology might be a bit misleading - an USP is not necessarily a shortest path in the given UG. Connections on a shortest path may simple require too much waiting (the el. connections simply do not follow well enough one another) and thus it might be that travelling along the paths with greater distance proof to be faster options.
	    
\subsection{USP-OR}

	We can easily extract the underlying path from a given connection. Now let us look at this from the other way - if, for a given EA query, we know the underlying shortest path, can we reconstruct the optimal connection? One thing we could do is to blindly follow the USP and at each stop take the first elementary connection to the next stop on the USP. This simple algorithm called \textit{ExpandUsp} is described in algorithm~\ref{alg:expusp}. 
	
	\color{algcolor}
	\begin{algorithm}[H]
		\color{inalgcolor}
		\caption{ExpandUsp}
		\label{alg:expusp}
		\textbf{Input} 
		\begin{itemize}
			\item timetable $T$
			\item USP $p = (v_{1}, v_{2}, ..., v_{k})$
			\item departure time $t$
		\end{itemize}
		\textbf{Algorithm}
		\begin{algorithmic}
			\STATE $c$ = empty connection
			\STATE $t' = t$
			\FORALL{$i \in \{1, ..., k - 1\}$}
				\STATE $e = argmin_{e' \in C_{T}(v_{i}, v_{i + 1})} \{dep(e')|\; dep(e') \geq t'\}$ \cmt{take first available el. conn.}
				\STATE $t' = arr(e)$
				\STATE $c$ .= $e$ \cmt{add the el.conn to the resulting connection}
			\ENDFOR
		\end{algorithmic}
		\textbf{Output}
		\begin{itemize}
			\item connection $c$
		\end{itemize}
	\end{algorithm}
	\color{black}	
	
	\noindent Will we get an optimal connection if we expanded all possible USPs between a pair of cities? We show that we will, provided the timetable has no \textit{overtaking} of elementary connections.
	
	\begin{definition}
        \textbf{Overtaking} \\
		An elementary connection $e_{1}$ \textbf{overtakes} $e_{2}$ if, and only if $dep(e_{1}) > dep(e_{2})$ and $arr(e_{1}) < arr(e_{2})$. 
    \end{definition}
    
    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/overtake}
		\end{center}
		\caption{\label{fig:overtake} An example of \textcolor{green!80!black}{\textbf{overtaking}} (in thick), depicted in a TE graph}
	\end{figure}
    
    \begin{lemma}
    	Let $T$ be a timetable without overtaking, $(x, t, y)$ an EA query in this timetable and $\mathcal{P} = \{p_{1}, p_{2}, ..., p_{k}\}$ a set of all USPs from $x$ to $y$. Define $c_{i} = ExpandUsp(T, p_{i}, t)$ to be the connection returned by the algorithm ExpandUsp~\ref{alg:expusp}. Then $\exists j:\; c_{j} = c_{x, t, y}^{*}$.
    \end{lemma}
    \begin{proof}
    	The optimal connection $c_{x, t, y}^{*}$ has an USP $p$ which must be present in the set $\mathcal{P}$, as it is the set of all USPs from $x$ to $y$. So $p = p_{j} = (v_{1}, v_{2},..., v_{l})$ from some $j$. We want to show that $c_{j}$ is the optimal connection. This may be shown inductively:
    	\begin{enumerate}
    		\item \textit{Base:} ExpandUsp reaches city $v_{1} = x$ as soon as possible (since the connection just starts there)
    		\item \textit{Induction:} ExpandUsp reached city $v_{i}$ as soon as possible, it then takes the first available el. connection to the next city $v_{i + 1}$. Since the el. connections do not overtake, ExpandUsp reached the city $v_{i + 1}$ as soon as possible.
    	\end{enumerate}
    \end{proof}
    
    \noindent We would like to stress, that overtaking is understood as a situation when one carrier overtakes another between \textit{two subsequent stations}. This situation is not that common, however it is still present in the real world timetables~\footnote{In Slovak rails, no overtaking has been detected. This is not surprising as (to my knowledge) there are not inter-station tracks with multiple rails going in one direction. French railways, on the other hand have designated high-speed tracks and thus overtaking is not impossible.}, as shown in table~\ref{tab:overtake}. All the same, we can simply remove the overtaken el. connections from the timetables, as they can be substituted by the quicker connection plus some waiting. \\
    
    \begin{table}[h!]
    	\centering
		\begin{tabular}{c|c}
		%legend
            \rowcolor{tablehead}
        	\textbf{Name} & \textbf{Overtaken edges (\%)} \\
        %data
			\hline
			air01 & 1\% \\
			cpru & 2\% \\
			cpza & 2\% \\
			montr & 1\% \\
			sncf & 2\% \\
			sncf-ter & 2\% \\
			sncf-inter & 8\% \\
			zsr & 0\% \\
		\end{tabular}
		\caption{\label{tab:overtake} Presence of overtaking in the timetables}
	\end{table}
	
	\noindent The basic idea of the algorithm \textit{USP-OR} (a short-cut for USP oracle) is therefore simply to pre-compute all the USPs for each pair of cities. Upon a query, the algorithm simply expands all the USPs for a given pair of cities, reconstructs respective connections and chooses the best one. \\
	
	\color{algcolor}
	\begin{algorithm}[H]
		\color{inalgcolor}
		\caption{USP-OR query}
		\label{alg:uspor-query}
		\textbf{Input} 
		\begin{itemize}
			\item timetable $T$
			\item OC query $(x, t, y)$
		\end{itemize}
		\textbf{Pre-computed} 
		\begin{itemize}
			\item $\forall x, y:$ set of USPs between $x$ and $y$ ($usps(x, y)$)
		\end{itemize}
		\textbf{Algorithm}
		\begin{algorithmic}
			\STATE $c^{*} = null$
			\FORALL{$p \in usps_{x, y}$}
				\STATE $c =$ \textit{ExpandUsp}$(T, p, t)$
				\STATE $c^{*} =$ better out of $c^{*}$ and $c$
			\ENDFOR
		\end{algorithmic}
		\textbf{Output}
		\begin{itemize}
			\item connection $c$
		\end{itemize}
	\end{algorithm}
	\color{black}
	
	\noindent We will now have a look at the four parameters of this oracle based method. As for the \textbf{preprocessing time}, we need to find optimal connections from each \textit{event} in the timetable to each \textit{city} (or in other words - solve all possible OC queries). On these connections we apply the $path$ function to obtain the USPs. The maximum number of events in one city is the height $h$ and there is $n$ cities, thus $hn$ is the upper bound on the number of events. One search from a single event to all cities can be done in time $\mathcal{O}(n \log n + m)$ with a time-dependent Dijkstra's algorithm run on the time-dependent graph of our timetable ($TD_{T}$). In worst case, $m$ could be as much as $n^{2}$ but in our timetables $m < n \log n$ in almost every case (\textit{air01} being the exception). We therefore get the preprocessing time $\bm{\mathcal{O}(hn^{2} \log n)}$. 
	
	As for the preprocessed space, we need to store USPs for each pair of the cities ($n^{2}$) and each USP might be long at most $\mathcal{O}(n)$ hops. What is more, there might be many USPs for a single pair of cities. Therefore we have two questions with respect to the space complexity of the preprocessing:
	\begin{enumerate}
		\item What is the average size of the USPs?
		\item How many are there USPs between a single pair of cities?
	\end{enumerate}
	\hspace*{\fill}
	
	\noindent The answer for the first question can be found in the table~\ref{tab:uspsize}: generally the average size of the USP is $\approx \sqrt{n}$. As for the second question, we will introduce the following definition:
	
	\begin{definition}
        \textbf{USP coefficient} \\
		Given a timetable $T$ and a pair of cities $x$, $y$, the USP coefficient $\bm{\tau_{T}(x, y)} = |usps_{T}(x, y)|$, where $\bm{usps_{T}(x, y)}$ is the set of USPs between $x$ and $y$. By $\bm{\tau_{T}}$ we will denote the average USP coefficient in timetable $T$.
    \end{definition}
    
    \noindent From the table~\ref{tab:usp200} we can see, that there are not many USPs on average, meaning that $\tau$ is usually some small number. Also, we see that it slightly increases with increasing time range (plot~\ref{plot:usp-air-timerange}), but not with increasing $n$, the size of the timetable (plot~\ref{plot:usp-sncf-size}). Thus we can consider $\tau$ to be bound by a small constant when it comes to daily timetables. 
    
    From the answers to our two questions we see that the \textbf{size of the preprocessed oracle} is about $\bm{\mathcal{O}(n^{2.5})}$ in real world timetables, though in general timetables, it is up to $\mathcal{O}(\tau n^{3})$.

	\begin{figure}[htb]
	\centering
	\makebox[0pt][c]{
    \begin{minipage}{0.45\textwidth} 
    	\centering 
		\begin{tabular}{c|c|c}
		%legend
			\rowcolor{tablehead}
			\textbf{Name} & \textbf{$\tau$} & \textbf{max $\tau(x, y)$} \\
		%data
			\hline
			air01-200d & 5.8 & 30 \\
			cpru-200d & 7.0 & 64 \\
			cpza-200d & 5.1 & 42 \\
			montr-200d & 4.3 & 30 \\
			sncf-200d & 4.3 & 24 \\
			sncf-inter-200d & 0.6 & 19 \\
			sncf-ter-200d & 6.1 & 33 \\
			zsr-200d & 2.5 & 19 \\
		\end{tabular}
		\captionof{table}{Average and maximal USP coefficients}
		\label{tab:usp200}
	\end{minipage}
	\hspace{1cm}
	\begin{minipage}{0.45\textwidth}
		 \centering
		\begin{tabular}{c|c}
		%legend
            \rowcolor{tablehead}
            \textbf{Name} & \textbf{avg USP size} \\
		%data
			\hline
			air01-200d & 3.0 \\
			cpru-200d & 13.8 \\
			cpza-200d & 11.1 \\
			montr-200d & 20.3 \\
			sncf-200d & 10.5 \\
			sncf-inter-200d & 7.9 \\
			sncf-ter-200d & 10.8 \\
			zsr-200d & 13.7 \\
		\end{tabular}
		\captionof{table}{Average USP sizes. Note extremely low value for airline timetable - this is due to the fact that UGs of airline timetables have small-world characteristics~\cite{sommerthesis10}}
		\label{tab:uspsize}
	\end{minipage}
    }
	\end{figure}

    \begin{figure}[htb]
	\centering
	\makebox[0pt][c]{
    \begin{minipage}{0.45\textwidth}  
	    \centering
	    \inputTikZ{./tikzpics/plot_usp_air01_timerange}
	    \captionof{figure}{Changing of $\tau$ with increased time range in \textit{air01} dataset. 1 day = about 800 in height}
	    \label{plot:usp-air-timerange}  
    \end{minipage}
	\hspace{1cm}
    \begin{minipage}{0.45\textwidth} 
    	\centering
	    \inputTikZ{./tikzpics/plot_usp_sncf_size}
	    \captionof{figure}{Changing of $\tau$ with increased number of stations in \textit{sncf} dataset}
	    \label{plot:usp-sncf-size}   
    \end{minipage}
    }
	\end{figure}
	
	\noindent The query time also depends on the USP coefficient of a given pair of cities $x$, $y$, as we have to try out all USPs in $usps(x, y)$. The expansion of a USP by \textit{ExpandUsp} function takes time linear in the size of the USP~\footnote{In time-dependent graphs, this requires a constant-time retrieval of the correct interpolation point of the cost function (the piece-wise linear function that tells us the traversal time of an arc at a given time) for some time $t$. More specifically, we need to obtain an interpolation point $argmin_{(t', l)} \{t'|t' > t\}$. If we assume uniform distribution of departures throughout the time range of the timetable, this can be implemented in constant time. Otherwise, binary search lookup is possible in time $\log h$}, leading to \textbf{query time} $\mathcal{O}(\tau(x, y) n)$, or $\bm{\mathcal{O}(\sqrt{n})}$ on average if we take into consideration the sizes of USPs and size of $\tau$. Note, that this is optimal, as we need to actually output the connection, which takes linear time in its size.
		
	Finally, the \textbf{stretch} of \textit{USP-OR} is \textbf{1}, as it returns exact answers. 
	
	\begin{table}[h!]{
		\begin{tabular}{l|c|c|c|c}
		%legend
			 & \cellcolor{oracle-clr} $\bm{prep}$ & \cellcolor{oracle-clr} $\bm{size}$ & \cellcolor{oracle-clr} $\bm{qtime}$ & \cellcolor{oracle-clr} $\bm{stretch}$ \\
		%data
			\hline
			\cellcolor{oracle-clr} \textbf{guaranteed} & $\mathcal{O}(hn^{3})$ & $\mathcal{O}(\tau n^{3})$ & $\mathcal{O}(\tau(x, y) \cdot n)$ & $1$ \\
			\cellcolor{oracle-clr} \textbf{on our timetables} & $\mathcal{O}(hn^{2} \log n)$ & $\mathcal{O}(n^{2.5})$ & avg. $\mathcal{O}(\sqrt{n})$ & $1$ \\
		\end{tabular}}
		\caption{\label{tab:uspor} The summary of the \textit{USP-OR} algorithm parameters}
	\end{table}
	
\subsection{USP-OR-A}
	    
	With \textit{USP-OR} the main disadvantage is its space consumption. We may decrease this space complexity by pre-computing USPs only among \textit{some} cities. The nodes that we select for this purpose will be called \textbf{access nodes} (AN for short), as for each city they would be the crucial nodes we need to pass in order to access most of the cities. It would be suitable for this access node set to have several desirable properties. In order to formulate them, we need to define a few terms first.
	
	\begin{definition}
        \textbf{Front neighbourhood} \\
		Given an timetable $T$ and access node set $\mathcal{A}$, a front neighbourhood of city $x$ are all cities (including $x$) that are reachable from $x$ \textit{not} via $\mathcal{A}$. Formally $\bm{neigh_{\mathcal{A}}(x)} = \{y|\exists$ path $p = (p_{1}, p_{2}, ..., p_{k})$ from $x$ to $y$ in $ug_{T}: p_{i} \neq a \; \forall a \in \mathcal{A}, \; i \in \{2, ..., k - 1\} \}$~\footnote{We leave out subscript identifying the timetable $T$. In situation with clear context, we may also leave out the $\mathcal{A}$ subscript}
    \end{definition}
    
    \noindent We define analogically \textbf{back neighbourhood} (denoted $\bm{bneigh_{\mathcal{A}}(x)}$), we only use reversed UG ($\overleftarrow{ug_{T}}$) in the definition. Note that the access nodes that are on the boundary of $x$'s neighbourhoods are also part of these neighbourhoods. These access nodes form some sort of separator between the $x$'s neighbourhood and the rest of the graph and we will call them \textbf{local access nodes (LAN)} ($\bm{lan_{\mathcal{A}}(x)} = \mathcal{A} \cap neigh_{\mathcal{A}}(x)$), or analogically \textbf{back local access nodes} ($\bm{blan_{\mathcal{A}}(x)}$). \\
    
    \noindent Now we may formulate the three desired properties of the access node set $\mathcal{A}$. Given a timetable $T$ and small constants $r_{1}$, $r_{2}$ and $r_{3}$, we would like to find access node set $\mathcal{A}$ such that:
    \begin{enumerate}
		\item The access node set is sufficiently small \\
		\begin{equation}
			|\mathcal{A}| \leq r_{1} \cdot \sqrt{n}
		\end{equation}
		\item The average square of neighbourhood size is at most $r_{2} \cdot n$: \\
		\begin{equation}
			\frac{\displaystyle \sum_{x \in ct_{T}}|neigh_{\mathcal{A}}(x)|^{2}}{\displaystyle n} \leq r_{2} \cdot n
		\end{equation}
		\item The number of local access nodes for each node is bound by $r_{3}$: \\
		\begin{equation}
			|lan_{\mathcal{A}}(x)| \leq r_{3}, \forall x \in ct_{T}
		\end{equation}
	\end{enumerate}
	\hspace{\fill}
	
	\noindent An access node set $\mathcal{A}$ with the above mentioned properties will be called $\bm{(r_{1}, r_{2}, r_{3})}$ \textbf{access node set} (AN set). We will now explain how the \textit{USP-OR-A} (USP-OR with access nodes) algorithm works and return to its analysis later. 
	
	During preprocessing, we need to find a good AN set and compute the USPs between every pair of access nodes. For every city $x \not \in \mathcal{A}$, we also store its $neigh_{\mathcal{A}}(x)$, $bneigh_{\mathcal{A}}(x)$, $lan_{\mathcal{A}}(x)$ and $blan_{\mathcal{A}}(x)$. On a query from $x$ to $y$ at time $t$, we will make a local search in the neighbourhood of $x$ to find out optimal connections to $x$'s local access nodes. Subsequently, we want to find out the earliest arrival times to each of $y$'s \textit{back} local access nodes. To do this, we take advantage of the pre-computed USPs between access nodes - try out all the pairs $u \in lan(x)$ and $v \in blan(y)$ and expand the stored USPs. Finally, we make a local search from each of $y$'s back LANs to $y$, but we run the search \textit{restricted} to $y$'s back neighbourhood. For more details, see algorithms~\ref{alg:uspora-prepro} and~\ref{alg:uspora-query} 
	
	\color{algcolor}
	\begin{algorithm}[H]
		\color{inalgcolor}
		\caption{USP-OR-A preprocessing}
		\label{alg:uspora-prepro}
		\textbf{Input} 
		\begin{itemize}
			\item timetable $T$
		\end{itemize}
		\textbf{Algorithm}
		\begin{algorithmic}
			\STATE find a good AN set $\mathcal{A}$
			\STATE $\forall x, y \in \mathcal{A}$ compute $usps(x, y)$
			\STATE $\forall x \in ct_{T} \setminus \mathcal{A}$ compute $neigh_{\mathcal{A}}(x)$, $bneigh_{\mathcal{A}}(x)$, $lan_{\mathcal{A}}(x)$ and $blan_{\mathcal{A}}(x)$
		\end{algorithmic}
		\textbf{Output}
		\begin{itemize}
			\item output everything we have computed
		\end{itemize}
	\end{algorithm}
	\color{black}
	
	\color{algcolor}
	\begin{algorithm}[H]
		\color{inalgcolor}
		\caption{USP-OR-A query}
		\label{alg:uspora-query}
		\textbf{Input} 
		\begin{itemize}
			\item timetable $T$
			\item OC query $(x, t, y)$
		\end{itemize}
		\textbf{Algorithm}
		\begin{algorithmic}
			\STATE \algsec{Local front search}
			\STATE perform time-dependent Dijkstra from $x$ at time $t$ up to $lan(x)$
			\IF {$y \in neigh(x)$}
				\STATE output optimal connection to $y$ obtained by Dijkstra's algorithm
			\ENDIF
			\STATE $\forall u \in lan(x)$ let $ea(u)$ be the EA to this node (obtained by Dijkstra's algorithm)
			\STATE $\forall u \in lan(x)$ let $oc(u)$ be the OC to this node (obtained by Dijkstra's algorithm)
			\STATE \algsec{Inter-AN search}
			\FORALL{$v \in blan(y)$}
				\STATE $oc(v) = null$
				\FORALL{$u \in lan(x)$}
					\FORALL{$p \in usps(u, v)$}
						\STATE $c =$ \textit{ExpandUsp}$(T, p, ea(u))$
						\STATE $oc(v) =$ better out of $oc(v)$ and $c$
					\ENDFOR
				\ENDFOR
			\ENDFOR
			\STATE $\forall v \in blan(y)$ let $ea(v) = end(oc(v))$ (the EA to this node)
			\STATE \algsec{Local back search}
			\FORALL{$v \in blan(y)$}
				\STATE perform time-dependent Dijkstra from $v$ at time $ea(v)$ to $y$ restricted to $bneigh(y)$
				\STATE let $fin(v)$ be the connection returned by Dijkstra's algorithm
			\ENDFOR
			\STATE $v^{*} = argmin_{v \in blan(y)} \{end(fin(v))\}$
			\STATE $u^{*} = from(oc(v))$
			\STATE output $c^{*} = oc(u^{*}) . oc(v^{*}) . fin(v^{*})$ \cmt{the dot ($.$) symbol is concatenation of connections)}
		\end{algorithmic}
		\textbf{Output}
		\begin{itemize}
			\item optimal connection $c_{(x, t, y)}^{*}$
		\end{itemize}
	\end{algorithm}
	\color{black}
	
	\begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/uspora}
		\end{center}
		\caption{\label{fig:uspora} Principle of access nodes in \textit{USP-OR-A} algorithm}
	\end{figure}
	
	
	
	    First we pre-compute some information on the timetable:
	    \begin{itemize}
	    	\item LANs for each city of the UG. Note that the only LAN for an access node is itself.
	    	\item The so called \textbf{back local access nodes} (back-LANs) for each city. We find them as we found LANs, but in underlying graph with reversed orientation.
	    	\item The back-neighbourhoods, created in the previous step
	    	\item All USPs among access nodes
	    \end{itemize}
	    \hspace{\fill}
	    
	    Upon a query from $u$ to $v$ at time $t$ ($(u, t, v)$) , we will:
	    \begin{enumerate}
	    	\item Do a local search (Dijkstra) in the neighbourhood of $u$, until we reach all of its LANs (each of them we reach at some specific time). The so-called \textbf{local step}
	    	\item Next we take back-LANs for the vertex $v$ and with the help of the pre-computed USPs we get the earliest arrival to each of them. The so-called \textbf{usp step}
	    	\item Finally we run a Dijkstra from each of $v$'s back-LANs, restricted to the back-neighbourhood of $v$. The so-called \textbf{final step}
	    \end{enumerate}
	    \hspace{\fill}
	    
	    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/uspora}
		\end{center}
		\caption{\label{fig:uspora} Principle of access nodes in \textit{USP-OR-A} algorithm}
	\end{figure}
	
	Let us now have a look at the four parameters of this method. \\
	
	\textbf{Preprocessing time}. We have to run a local search, e.g. Dijkstra's algorithm, from each city in the graph, terminating at the city's LANs. Thus the Dijkstra's algorithm runs in $neigh_{Acc}^{2}(v)$. We have $\mathcal{O}(n)$ cities with average neighbourhood of the size $\mathcal{O}(\sqrt{n})$, leading to time complexity $\mathcal{O}(n^{2})$. However, we also have to pre-compute the USPs among all pairs of access nodes, which takes time at most $\mathcal{O}(hn^{2.5})$. \\
	
	TODO \textbf{Lema with average}. \\
	
	\textbf{Preprocessed space}. The pre-processed space consumption is now decreased to $\mathcal{O}(\tau n^{2})$ as we have at most $\mathcal{O}(n)$ pairs of access nodes for which we pre-compute USPs. We remember other things as well but their space complexity is bound by the mentioned term. \\
	
		\textbf{Query time}. The \textit{local step} takes at most $\mathcal{O}(n)$ time. In \textit{USP step} we try all USPs for all pairs of $u$'s LANs and $v$'s back-LANs, leading to $\mathcal{O}(l^{2} \tau n)$, which is linear if we consider $\tau$ and $l$ constant. Finally, the \textit{final step} makes $l$ Dijkstra searches in the neighbourhood of $v$, which again takes linear time. Thus the overall query time may also be considered linear. \\
	
	\textbf{Stretch}. The algorithm is exact. \\
	    
	\section{Choosing the right Access node set}
	
	The challenge in \textit{USP-OR-A} comes down to selection of the best access node set, or at least such that satisfies the three mentioned properties. There was a detected possibility for a trade-off - by increasing the access node set size, the average number of LANs as well as average neighbourhood size went down. \\
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Selected by} & 
	           	\textbf{Size of AN set} &
	           	\textbf{Avg. LAN size} &
	           	\textbf{Avg. neighborhood size} \\
	        %data
	        \hline
			high BC & 33 & 10.65 & 426.5 \\
			high BC & 55 & 3.5 & 92.1 \\
			high BC & 75 & 2.8 & 60.5 \\
			high degree & 33 & 19.76 & 484 \\
			high degree & 55 & 6.9 & 95 \\
			high degree & 75 & 2.54 & 34.7 \\
	        \end{tabular}}
		\caption{\label{tab:accnodesza} Properties of access nodes selected by different methods. For underlying graph of \textit{cpza} (1128 vertices, $\sqrt{1128} \approx 33$)}
	        \normalsize
	\end{table}
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Selected by} & 
	           	\textbf{n/m} &
	           	\textbf{Size of AN set} &
	           	\textbf{Avg. neighborhood size} ($\sqrt{n}$) &
	           	\textbf{Avg. LAN size} \\
	        %data
	        \hline
			high degree & 2646/7994 & 182 & 49.8 (51.4) & 4.24 \\
			high degree & 2000/6075 & 130 & 44.3 (44.7) & 4.25 \\
			high degree & 1500/4548 & 70 & 38.2 (38.7) & 3.42 \\
			high degree & 1000/3216 & 52 & 30.1 (31.6) & 3.23 \\
			high degree & 750/2415 & 40 & 26 (27.3) & 2.97 \\
			high degree & 500/1583 & 22 & 22 (22.3) & 2.3 \\
			high degree & 250/835 & 25 & 16.6 (15.8) & 3.36 \\
			high degree & 100/313 & 16 & 10.4 (10) & 2.13 \\
			high BC & 2646/7994 &  &  &  \\
			high BC & 2000/6075 &  &  &  \\
			high BC & 1500/4548 &  &  &  \\
			high BC & 1000/3216 &  &  &  \\
			high BC & 750/2415 &  &  &  \\
			high BC & 500/1583 &  &  &  \\
			high BC & 250/835 &  &  &  \\
			high BC & 100/313 &  &  &  \\
	        \end{tabular}}
		\caption{\label{tab:accnodessncf} Properties of access nodes selected by different methods. For underlying graph of \textit{sncf} (French railways)}
	        \normalsize
	\end{table}
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Name} & 
	           	\textbf{$|AN|$/$|LAN|$ (degs, avg)} &
	           	\textbf{$|AN|$/$|LAN|$ (degs, max)} &
	           	\textbf{$|AN|$/$|LAN|$ (betw, avg)} &
	           	\textbf{$|AN|$/$|LAN|$ (betw, max)} \\
	        %data
	        \hline
		        air01-200d & 56/8.4 & 87/4.1 & 67/7.7 & 200/0 \\
				cpru-200d & 24/1.6 & 43/1.5 & 26/1.7 & 44/1.6 \\
				cpza-200d & 18/2.0 & 77/1.3 & 24/2.3 & 47/1.5 \\
				montr-200d & 21/2.0 & 83/1.1 & 47/1.5 & 121/1.4 \\
				sncf-200d & 12/1.7 & 20/1.6 & 20/2.3 & 42/1.6 \\
				sncf-inter-200d & 17/2.3 & 33/1.4 & 24/1.8 & 43/1.3 \\
				sncf-ter-200d & 9/1.7 & 32/1.7 & 17/1.5 & 39/1.7 \\
				zsr-200d & 16/2.0 & 50/1.4 & 18/1.7 & 41/1.5 \\
	        \end{tabular}}
		\caption{\label{tab:anbetwdegs} Necessary access node set sizes when choosing ANs based on degree or betweenness. The avg/max parameter specifies, if we wanted average neighborhood under $\sqrt{n}$ or all of them (maximum neighborhood under $\sqrt{n}$). Corresponding average LAN sizes are after the backslash.}
	        \normalsize
	\end{table}