\subsection{USP}

	In section~\ref{sec:prel} we have defined a timetable as a set of elementary connections. While do not pose any other restrictions on this set or on the elementary connections themselves, the real world timetables usually have a specific nature. Quite often are the connections repetitive, that is, the same sequence of elementary connections is repeated in several different moments throughout the day.
	
	Another thing we may notice is that if we talk about \textit{optimal} connections between a pair of distant cities $u$ and $v$, we are often left with a few possibilities as to \textit{which way should we go}. This is not only because the underlying graph is usually quite sparse~\footnote{Maybe with exception of the airline timetables, which tend to be more dense}, but also because for longer distances we generally need to make use of some express connection that stops only in (small number of) bigger cities.
	
	Thus the main idea which will repeat often throughout this section: \textit{when carrying out an optimal connection between a pair of cities, one often goes along the same path regardless of the starting time}. \\
	
	\noindent To formalize this idea, we will introduce the definition of an \textit{underlying shortest path} - a path in UG that corresponds to some optimal connection in the timetable. To do this, we will first define a function $path$ that extracts the \textbf{underlying path} (trajectory in the UG) from a given connection. Let $c$ be a connection $c = (e_{1}, e_{2}, ..., e_{k})$. \\
	
	\begin{equation*}
		\bm{path(c)} = shrink(from(e_{1}), from(e_{2}), ..., from(e_{k}), to(e_{k}))
	\end{equation*}
	
	\noindent Note, that if the connection involves waiting in a city (as e.g. in picture~\ref{fig:pathfunc}), $e_{x}^{i} = e_{x}^{i + 1}$ for some $i$. That is why we apply the $shrink$ function, which replaces any sub-sequences of the type $(z, z, ..., z)$ by $(z)$ in a sequence. This was rather technical way of expressing a simple intuition - for a given connection, the $path$ function simply outputs a sequence of visited cities. Now we can formalize the underlying shortest path.
	
	\begin{definition}
        \textbf{Underlying shortest path (USP)} \\
		A path $p = (v_{1}, v_{2}, ..., v_{k})$ in $UG_{T}$ is an \textbf{underlying shortest path} if and only if $\exists t \in \mathcal{N}: p = path(c_{(v_{1}, t, v_{k})}^{*}), c_{(v_{1}, t, v_{k})}^{*} \in C_{T}$
    \end{definition}
    
    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/pathfunc}
		\end{center}
		\caption{\label{fig:pathfunc} The $path$ function applied on a connection to get the underlying path}
	\end{figure}
	
	\noindent Please note that the terminology might be a bit misleading - an USP is not necessarily a shortest path in the given UG. Connections on a shortest path may simple require too much waiting (the el. connections simply do not follow well enough one another) and thus it might be that travelling along the paths with greater distance proof to be faster options.
	    
\subsection{USP-OR}

	We can easily extract the underlying path from a given connection. Now let us look at this from the other way - if, for a given EA query, we know the underlying shortest path, can we reconstruct the optimal connection? One thing we could do is to blindly follow the USP and at each stop take the first elementary connection to the next stop on the USP. This simple algorithm called \textit{ExpandUsp} is described in algorithm~\ref{alg:expusp}. 
	
	\color{algcolor}
	\begin{algorithm}[H]
		\color{inalgcolor}
		\caption{ExpandUsp}
		\label{alg:expusp}
		\textbf{Input} 
		\begin{itemize}
			\item timetable $T$
			\item USP $p = (v_{1}, v_{2}, ..., v_{k})$
			\item departure time $t$
		\end{itemize}
		\textbf{Algorithm}
		\begin{algorithmic}
			\STATE $c$ = empty connection
			\STATE $t' = t$
			\FORALL{$i \in \{1, ..., k - 1\}$}
				\STATE $e = argmin_{f \in C_{T}(v_{i}, v_{i + 1})} \{dep(f)|\; dep(f) \geq t'\}$ \cmt{take first available el. conn.}
				\STATE $t' = arr(e)$
				\STATE $c$ .= $e$ \cmt{add the el.conn to the resulting connection}
			\ENDFOR
		\end{algorithmic}
		\textbf{Output}
		\begin{itemize}
			\item connection $c$
		\end{itemize}
	\end{algorithm}
	\color{black}	
	
	\noindent Will we get an optimal connection if we expanded all possible USPs between a pair of cities? We show that we will, provided the timetable has no \textit{overtaking} of elementary connections.
	
	\begin{definition}
        \textbf{Overtaking} \\
		An elementary connection $e_{1}$ \textbf{overtakes} $e_{2}$ if, and only if $dep(e_{1}) > dep(e_{2})$ and $arr(e_{1}) < arr(e_{2})$. 
    \end{definition}
    
    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/overtake}
		\end{center}
		\caption{\label{fig:overtake} An example of \textcolor{green!80!black}{\textbf{overtaking}} (in thick), depicted in a TE graph}
	\end{figure}
    
    \begin{lemma}
    	Let $T$ be a timetable without overtaking, $(x, t, y)$ an EA query in this timetable and $\mathcal{P} = \{p_{1}, p_{2}, ..., p_{k}\}$ a set of all USPs from $x$ to $y$. Define $c_{i} = ExpandUsp(T, p_{i}, t)$ to be the connection returned by the algorithm ExpandUsp~\ref{alg:expusp}. Then $\exists j:\; c_{j} = c_{x, t, y}^{*}$.
    \end{lemma}
    \begin{proof}
    	The optimal connection $c_{x, t, y}^{*}$ has an USP $p$ which must be present in the set $\mathcal{P}$, as it is the set of all USPs from $x$ to $y$. So $p = p_{j} = (v_{1}, v_{2},..., v_{l})$ from some $j$. We want to show that $c_{j}$ is the optimal connection. This may be shown inductively:
    	\begin{enumerate}
    		\item \textit{Base:} ExpandUsp reaches city $v_{1} = x$ as soon as possible (since the connection just starts there)
    		\item \textit{Induction:} ExpandUsp reached city $v_{i}$ as soon as possible, it then takes the first available el. connection to the next city $v_{i + 1}$. Since the el. connections do not overtake, ExpandUsp reached the city $v_{i + 1}$ as soon as possible.
    	\end{enumerate}
    \end{proof}
	
	This simple approach works fine, but only provided there is no overtaking in the timetable. However, even if there is overtaking, we can fix this small problem by:
	\begin{itemize}
		\item \textit{Removing overtaken elementary connection} - in our simplified version of the EAP problem we do not consider parameters such as the cost of the travel. Thus overtaken el. connections are redundant as they can be replaced by their overtaking el. connections plus some waiting.
		\item \textit{Considering all elementary connections} up to the earliest arrival time to the next city in USP - this might however increase the time complexity of restoring the optimal connection from USP, thus we will use the first approach
	\end{itemize}
	\hspace{\fill}
	
	The basic idea of the algorithm \textit{USP-OR} is therefore simply to pre-compute all the USPs for each pair of cities. Then, upon query, the algorithm simply tries out all the USPs for a given pair of cities, reconstructs respective connections and chooses the best one (the one that arrives the soonest). Very simple. \\
	
	We will now have a look at the four parameters of this oracle-based method. \\
	
	\textbf{Preprocessing time}. Basically, we need to find optimal connections from each \textit{event} in the timetable to each city (or in other words - solve all possible EAP queries). We can do it by running Dijkstra algorithm $hn$ times (from each event), obtaining the time complexity $\mathcal{O}(hn^{3})$. \\
	
	\textbf{Preprocessed space}. We store USPs for each pair of cities ($n^{2}$) and each USP might be long at most $\mathcal{O}(n)$. The question is, how many different USPs there is for a pair of cities? We will call this number the \textbf{USP coefficient for a given city pair} and will denote it as $\tau_{A, B}$ (where $A$ and $B$ is the given pair of cities). The average of USP coefficients for all city pairs will be called simply the \textbf{USP coefficient} and denoted as $\tau$ ($\tau = avg_{A \neq B} (\tau_{A, B})$). So how big is $\tau$ for real-world timetables? See table \ref{tab:usps}. \\
	
	\begin{table}{
		\scriptsize
		\begin{tabular}{c|c|c|c|c|c}
		%legend
			\hline
			\rowcolor{tablehead}
			\textbf{Name} & \textbf{n/m of UG} & \textbf{height} & \textbf{time range} & \textbf{avg $\tau_{A, B}$} & \textbf{max $\tau_{A, B}$} \\
		%data
			\hline
			air01 & 100/2274 & 10000 & month & 33.55 & 170 \\
			air01 & 250/4568 & 10000 & month & 35.8 & 193 \\
			air01 & 287/4668 & 24050 & month & TODO & TODO \\
			air01 & 100 & - & day &  &  \\
			air01 & 250 & - & day &  &  \\
			air01 & 284/4382 & 789 & day & 4.6 & 30 \\
			\hline
			cpru & 50/120 & 20 & day & 0.62 & 4 \\
			cpru & 100/286 & 228 & day & 6.5 & 40 \\
			cpru & 250/696 & 228 & day & 9.23 & 63 \\
			cpru & 871/2415 & 239 & day & 10.3 & 65 \\
			\hline
			cpza & 43/87 & 20 & day & 0.6 & 5 \\
			cpza & 100/283 & 333 & day & 4.3 & 27 \\
			cpza & 250/711 & 369 & day & 7.9 & 66 \\
			cpza & 1108/2778 & 369 & day & 11.7 & 69 \\
			\hline
			montr & 49/77 & 20 & day & 0.7 & 3 \\
			montr & 100/164 & 359 & day & 1.5 & 10 \\
			montr & 217/349 & 359 & day & 3.8 & 29 \\
			\hline
			sncf & 20 & 8 & day &  &  \\
			sncf & 30 & 10 & day &  &  \\
			sncf & 50 & 20 & day &  &  \\
			sncf & 100 & - & day &  &  \\
			sncf & 250 & - & day &  &  \\
			sncf & 500 & - & day &  &  \\
			sncf & 750 & - & day &  &  \\
			sncf & 1000 & - & day &  &  \\
			sncf & 1500 & - & day &  &  \\
			sncf & 2000 & - & day &  &  \\
			sncf & full & - & day &  &  \\
			\hline
			zsr & 100/268 & 10000 & year & 101.4 & 1250 \\
			zsr & 233/588 & 10000 & year & 170.1 & 1219 \\
			zsr & 233/588 & 60308 & year & TODO & TODO \\
			zsr & 96/252 & 142 & day & 1.9 & 14 \\
			zsr & 225/514 & 142 & day & 2.4 & 19 \\
		\end{tabular}}
		\caption{\label{tab:usps}$\tau$ - the USP coefficient for different timetables}
		\normalsize
	\end{table}
	
	\textbf{Query time}. Query time depends also on the USP coefficient of a given pair of cities, as we have to try out all USPs for that given pair. As each reconstruction of the connection from the respective USP costs linear time, the time complexity can be estimated as $\mathcal{O}(\tau n)$. As $\tau$ is basically a constant and we need linear time to actually output a connection, this can be deemed as optimal complexity. \\
	
	\textbf{Stretch}. The algorithm is exact. \\
	    
	    \section{USP-OR-A}
	    
	    With \textit{USP-OR} the main disadvantage is its space consumption. We may decrease this space complexity by pre-computing USPs only among \textit{some} nodes, which we will call \textbf{access nodes} (AN). It would be suitable for this access node set (denoted $Acc$) to have several properties, which will be clear from the way we will use it later. Before we list these properties, we need to establish a few terms. We will call a \textbf{neighbourhood} of a city $v$ ($neigh_{Acc}(v)$) the smallest set of cities reachable from $v$ \textit{not} via access nodes in the underlying graph. Then, the access nodes belonging to the city's neighbourhood will be called the \textbf{local access nodes} ($LAN_{Acc}(v)$). Intuitively, the local access nodes for a node $v$ form some kind of separator between the $v$'s neighbourhood and the rest of the graph.\\
	    
	    Now we may formulate the three desired properties of the access node set $Acc$:
	    \begin{itemize}
	    	\item The access node set is sufficiently small $|Acc| = \mathcal{O}(\sqrt{n})$
	    	\item The average neighbourhood size is sufficiently small $avg_{v} \; neigh_{Acc}(v) = \mathcal{O}(\sqrt{n})$
	    	\item The number of local access nodes for each node is bound by a constant $LAN_{Acc}(v) < l$
	    \end{itemize}
	\hspace{\fill}
	
	%Note that we are talking here in the big $\mathcal{O}$ notation and using ``constant $l$''. This is meant in such a way, that by increasing 
	    
	    First we pre-compute some information on the timetable:
	    \begin{itemize}
	    	\item LANs for each city of the UG. Note that the only LAN for an access node is itself.
	    	\item The so called \textbf{back local access nodes} (back-LANs) for each city. We find them as we found LANs, but in underlying graph with reversed orientation.
	    	\item The back-neighbourhoods, created in the previous step
	    	\item All USPs among access nodes
	    \end{itemize}
	    \hspace{\fill}
	    
	    Upon a query from $u$ to $v$ at time $t$ ($(u, t, v)$) , we will:
	    \begin{enumerate}
	    	\item Do a local search (Dijkstra) in the neighbourhood of $u$, until we reach all of its LANs (each of them we reach at some specific time). The so-called \textbf{local step}
	    	\item Next we take back-LANs for the vertex $v$ and with the help of the pre-computed USPs we get the earliest arrival to each of them. The so-called \textbf{usp step}
	    	\item Finally we run a Dijkstra from each of $v$'s back-LANs, restricted to the back-neighbourhood of $v$. The so-called \textbf{final step}
	    \end{enumerate}
	    \hspace{\fill}
	    
	    \begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/uspora}
		\end{center}
		\caption{\label{fig:uspora} Principle of access nodes in \textit{USP-OR-A} algorithm}
	\end{figure}
	
	Let us now have a look at the four parameters of this method. \\
	
	\textbf{Preprocessing time}. We have to run a local search, e.g. Dijkstra's algorithm, from each city in the graph, terminating at the city's LANs. Thus the Dijkstra's algorithm runs in $neigh_{Acc}^{2}(v)$. We have $\mathcal{O}(n)$ cities with average neighbourhood of the size $\mathcal{O}(\sqrt{n})$, leading to time complexity $\mathcal{O}(n^{2})$. However, we also have to pre-compute the USPs among all pairs of access nodes, which takes time at most $\mathcal{O}(hn^{2.5})$. \\
	
	TODO \textbf{Lema with average}. \\
	
	\textbf{Preprocessed space}. The pre-processed space consumption is now decreased to $\mathcal{O}(\tau n^{2})$ as we have at most $\mathcal{O}(n)$ pairs of access nodes for which we pre-compute USPs. We remember other things as well but their space complexity is bound by the mentioned term. \\
	
		\textbf{Query time}. The \textit{local step} takes at most $\mathcal{O}(n)$ time. In \textit{USP step} we try all USPs for all pairs of $u$'s LANs and $v$'s back-LANs, leading to $\mathcal{O}(l^{2} \tau n)$, which is linear if we consider $\tau$ and $l$ constant. Finally, the \textit{final step} makes $l$ Dijkstra searches in the neighbourhood of $v$, which again takes linear time. Thus the overall query time may also be considered linear. \\
	
	\textbf{Stretch}. The algorithm is exact. \\
	    
	\section{Choosing the right Access node set}
	
	The challenge in \textit{USP-OR-A} comes down to selection of the best access node set, or at least such that satisfies the three mentioned properties. There was a detected possibility for a trade-off - by increasing the access node set size, the average number of LANs as well as average neighbourhood size went down. \\
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Selected by} & 
	           	\textbf{Size of AN set} &
	           	\textbf{Avg. LAN size} &
	           	\textbf{Avg. neighborhood size} \\
	        %data
	        \hline
			high BC & 33 & 10.65 & 426.5 \\
			high BC & 55 & 3.5 & 92.1 \\
			high BC & 75 & 2.8 & 60.5 \\
			high degree & 33 & 19.76 & 484 \\
			high degree & 55 & 6.9 & 95 \\
			high degree & 75 & 2.54 & 34.7 \\
	        \end{tabular}}
		\caption{\label{tab:accnodesza} Properties of access nodes selected by different methods. For underlying graph of \textit{cpza} (1128 vertices, $\sqrt{1128} \approx 33$)}
	        \normalsize
	\end{table}
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Selected by} & 
	           	\textbf{n/m} &
	           	\textbf{Size of AN set} &
	           	\textbf{Avg. neighborhood size} ($\sqrt{n}$) &
	           	\textbf{Avg. LAN size} \\
	        %data
	        \hline
			high degree & 2646/7994 & 182 & 49.8 (51.4) & 4.24 \\
			high degree & 2000/6075 & 130 & 44.3 (44.7) & 4.25 \\
			high degree & 1500/4548 & 70 & 38.2 (38.7) & 3.42 \\
			high degree & 1000/3216 & 52 & 30.1 (31.6) & 3.23 \\
			high degree & 750/2415 & 40 & 26 (27.3) & 2.97 \\
			high degree & 500/1583 & 22 & 22 (22.3) & 2.3 \\
			high degree & 250/835 & 25 & 16.6 (15.8) & 3.36 \\
			high degree & 100/313 & 16 & 10.4 (10) & 2.13 \\
			high BC & 2646/7994 &  &  &  \\
			high BC & 2000/6075 &  &  &  \\
			high BC & 1500/4548 &  &  &  \\
			high BC & 1000/3216 &  &  &  \\
			high BC & 750/2415 &  &  &  \\
			high BC & 500/1583 &  &  &  \\
			high BC & 250/835 &  &  &  \\
			high BC & 100/313 &  &  &  \\
	        \end{tabular}}
		\caption{\label{tab:accnodessncf} Properties of access nodes selected by different methods. For underlying graph of \textit{sncf} (French railways)}
	        \normalsize
	\end{table}
	
	\begin{table}[h!]{
		\scriptsize
	    \begin{tabular}{l|c|c|c|c}
		%legend
		\hline
			\rowcolor{tablehead}
	           	\textbf{Name} & 
	           	\textbf{$|AN|$/$|LAN|$ (degs, avg)} &
	           	\textbf{$|AN|$/$|LAN|$ (degs, max)} &
	           	\textbf{$|AN|$/$|LAN|$ (betw, avg)} &
	           	\textbf{$|AN|$/$|LAN|$ (betw, max)} \\
	        %data
	        \hline
		        air01-200d & 56/8.4 & 87/4.1 & 67/7.7 & 200/0 \\
				cpru-200d & 24/1.6 & 43/1.5 & 26/1.7 & 44/1.6 \\
				cpza-200d & 18/2.0 & 77/1.3 & 24/2.3 & 47/1.5 \\
				montr-200d & 21/2.0 & 83/1.1 & 47/1.5 & 121/1.4 \\
				sncf-200d & 12/1.7 & 20/1.6 & 20/2.3 & 42/1.6 \\
				sncf-inter-200d & 17/2.3 & 33/1.4 & 24/1.8 & 43/1.3 \\
				sncf-ter-200d & 9/1.7 & 32/1.7 & 17/1.5 & 39/1.7 \\
				zsr-200d & 16/2.0 & 50/1.4 & 18/1.7 & 41/1.5 \\
	        \end{tabular}}
		\caption{\label{tab:anbetwdegs} Necessary access node set sizes when choosing ANs based on degree or betweenness. The avg/max parameter specifies, if we wanted average neighborhood under $\sqrt{n}$ or all of them (maximum neighborhood under $\sqrt{n}$). Corresponding average LAN sizes are after the backslash.}
	        \normalsize
	\end{table}