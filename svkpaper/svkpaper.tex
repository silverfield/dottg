%---------------------------------------------------------------------
%   documentclass
%---------------------------------------------------------------------
\documentclass{svk_long_en}

%---------------------------------------------------------------------
%   packages
%---------------------------------------------------------------------

\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[titletoc, page]{appendix}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{caption}
\usepackage{cite} %bibtex
\usepackage{color} %for \definecolor
\usepackage{colortbl} %for \rowcolor command
\usepackage{courier}
\usepackage{enumitem}
\usepackage{eucal} %for nice letters like \mathcal{A}
\usepackage{floatflt} %to have tables and text beside
\usepackage[T1]{fontenc} %pekne makcene
\usepackage{hyperref} %odkazy
\usepackage{listings}
\usepackage{lmodern} %spolu s T1 smooth font!
\usepackage{lscape}
\usepackage{mathtools}
\usepackage{multirow}% http://ctan.org/pkg/multirow
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage{pifont} %for ticks (check symbols)
\usepackage{scalefnt}
\usepackage{setspace}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{titlesec} %section titles font size change
\usepackage{xcolor} %for \colorlet

\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{shapes,fit,calc,shadows,plotmarks}

%---------------------------------------------------------------------
%   various settings
%---------------------------------------------------------------------

\definecolor{tablehead}{RGB}{238,233,233} %nice smooth grey
\definecolor{algcolor}{RGB}{0,0,0}
\definecolor{inalgcolor}{RGB}{0,0,0}
\definecolor{lstcolor}{RGB}{238,233,233}

\setlength{\parindent}{0pt} %we don't need no indentation

\graphicspath{{./pics/}} %picture dir

\setlist{nolistsep} %so that lists have normal spacing

\colorlet{city-clr}{green!70!black}
\colorlet{elcon-clr}{red}
\colorlet{event-clr}{blue}
\colorlet{waiting-clr}{olive}
\colorlet{cmt-clr}{gray}
\colorlet{oracle-clr}{orange!30}
\colorlet{algsec-clr}{black!50!red}

\renewcommand{\arraystretch}{1.1} %spacing of table rows

%---------------------------------------------------------------------
%   environments
%---------------------------------------------------------------------

\newcommand{\cmt}[1]{{\color{cmt-clr} \hspace*{1cm} \# \textit{#1}}}
\newcommand{\algsec}[1]{\textcolor{algsec-clr}{\textbf{\underline{#1}}}} 
\newcommand{\deftoken}{\boldmath{$\mathcal{DEFINITION}$}}
\newcommand{\restoken}{\boldmath{$\mathcal{RESULT}$}}
\newcommand{\dotoken}{\boldmath{$\mathcal{DO METHOD}$}}
\newcommand{\textbff}[1]{{\large \textbf{#1}}}
\newcommand{\tick}{\ding{52}}
\newcommand{\cross}{\ding{55}}

\interfootnotelinepenalty=10000

\newcommand{\inputTikZ}[1]{%
    \beginpgfgraphicnamed{#1-external}%
    \input{#1.tikz}%
    \endpgfgraphicnamed%
}

%---------------------------------------------------------------------
%   document
%---------------------------------------------------------------------
\begin{document}
%---------------------------------------------------------------------
%   FRONTMATTER ------------------------------------------------------
%--------------------------------------------------------------------- 
    \title{Underlying shortest paths in timetables}
	\author{František Hajnovič\inst{1}
	\email{ferohajnovic@gmail.sk}}
	
	\supervisor{Rastislav Královič\inst{1}
	\email{kralovic@dcs.fmph.uniba.sk}}
	
	\titlerunning{Underlying shortest paths in timetables}
	\authorrunning{Hajnovič}
	
	\institute{
	Katedra informatiky,
	FMFI UK,
	Mlynská Dolina
	842~48~Bratislava}

	\maketitle

	\begin{abstract}
	We introduce methods to speed-up optimal connection queries in timetables based on pre-computing paths that are worth to follow. We present a very fast but space consuming method \textit{USP-OR} which we enhance to considerably decrease the size of the preprocessed data while still achieving speed-ups up to 6 against time-dependent Dijkstra's algorithm implemented with Fibonacci heap priority queue.
	\keywords{optimal connection, timetable, Dijkstra's algorithm, underlying shortest paths}
	\end{abstract}

%---------------------------------------------------------------------
%   MAINMATTER  ------------------------------------------------------
%---------------------------------------------------------------------
    %\mainmatter
    
\section{Introduction}

	We consider a problem of looking for an optimal connection (from $a$ at time $t$ to $b$ $\rightarrow$ $\bm{c^{*}_{(a, t, b)}}$)  in timetables on which we carried out some pre-processing. We define \textbf{timetable} simply as a set of \textbf{elementary connections}, which are quadruples $(x, y, p, q)$ meaning that a train departs from \textbf{city} $x$ at time $p$ an arrives to city $y$ at time $q$. A \textbf{connection} is simply a valid sequence of elementary connections which may include also some waiting in visited cities. We also define an \textbf{underlying graph} ($\bm{ug_{T}}$) of the timetable $T$ whose nodes are the cities and there is an arc $(x, y) \iff$ some el. connection $(x, y, p, q) \in T$.

\begin{table}[h!]
    	\centering
        \begin{tabular}{c|c|c|c}
        %legend
            \rowcolor{tablehead}
            \multicolumn{2}{>{\columncolor{tablehead}}c|}{\textbf{Place}} & \multicolumn{2}{>{\columncolor{tablehead}}c}{\textbf{Time}} \\
			\hline
           	\rowcolor{tablehead}
            \textbf{From} & \textbf{To} & \textbf{Departure} & \textbf{Arrival} \\
		%data
			\hline
            \textcolor{city-clr}{A} & \textcolor{city-clr}{B} & 10:00 & 10:45 \\
			\textcolor{city-clr}{B} & \textcolor{city-clr}{C} & 11:00 & 11:30 \\
			\textcolor{city-clr}{B} & \textcolor{city-clr}{C} & 11:30 & 12:10 \\
			\textcolor{city-clr}{B} & \textcolor{city-clr}{A} & 11:20 & 12:30 \\
			\textcolor{city-clr}{C} & \textcolor{city-clr}{A} & 11:45 & 12:15 \\
		\end{tabular}
		\caption{\label{table:tt} An example of a timetable.}
	\end{table}
	
	\begin{figure}[h!]
        \begin{center}
			\inputTikZ{./tikzpics/ug}
        \end{center}
		\caption{\label{fig:ug} An underlying graph of the timetable~\ref{table:tt}.}
	\end{figure}
	
	Finally, we define the \textbf{underlying shortest path} (USP) to be every path $p$ in $ug_{T}$ such that for some optimal connection $c^{*}_{(a, t, b)}$: $path(c^{*}_{(a, t, b)}) = p$, where function $path$ simply extracts the sequence of cities visited by the connection (see picture~\ref{fig:pathfunc}).
	
	\begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/pathfunc}
		\end{center}
		\caption{\label{fig:pathfunc} The $path$ function applied on a connection to get the underlying path.}
	\end{figure}

\section{Approaches}

	\subsection{\textit{USP-OR}}
	
		Our first method, called \textit{USP-OR} (\textbf{USP} \textbf{or}acle), is based on pre-computing USPs between every pair of cities. Then, upon a query from $x$ to $y$ at time $t$ we consider one by one the computed USPs between $x$ and $y$ and perform a reverse operation to the $path$ function - $expand(p)$ where $p$ is an USP. The $expand$ function simply follows the sequence of cities in $p$ and from each of them it takes the first available el. connection to the next one, thus constructing one by one a connection from $x$ to $y$. 
		
		\color{algcolor}
		\begin{algorithm}[H]
			\color{inalgcolor}
			\caption{\textit{USP-OR} query}
			\label{alg:uspor-query}
			\textbf{Input} 
			\begin{itemize}
				\item timetable $T$
				\item OC query $(x, t, y)$
			\end{itemize}
			\textbf{Pre-computed} 
			\begin{itemize}
				\item $\forall x, y:$ set of USPs between $x$ and $y$ ($usps(x, y)$)
			\end{itemize}
			\textbf{Algorithm}
			\begin{algorithmic}
				\STATE $c^{*} = null$
				\FORALL{$p \in usps_{x, y}$}
					\STATE $c =$ \textit{Expand}$(T, p, t)$
					\STATE $c^{*} =$ better out of $c^{*}$ and $c$
				\ENDFOR
			\end{algorithmic}
			\textbf{Output}
			\begin{itemize}
				\item connection $c$
			\end{itemize}
		\end{algorithm}
		\color{black}

		Define an elementary connection $e_{1}$ to \textbf{overtake} $e_{2}$ $\iff$ $depart(e_{1}) > depart(e_{2})$ and $arrive(e_{1}) < arrive(e_{2})$~\cite{tdroute09}. If the timetable $T$ has no overtaking el. connections, the \textit{USP-OR} algorithm returns exact answers, which can be easily proved. The table~\ref{tab:uspor} summarizes the parameters of \textit{USP-OR} based on the following parameters of the timetable:
		\begin{itemize}
			\item $\bm{\tau}$ - the average number of different USPs between pairs of cities - the \textbf{USP coefficient}
			\item $\bm{\gamma}$ - the average size (i.e. number of el. conn.) of optimal connections - the \textbf{OC radius}
			\item $\bm{\delta}$ - the \textbf{density} of $T$ defined by $\frac{\bm{m}}{\bm{n}}$ - number of arcs of $ug_{T}$ divided by number of cities
			\item $\bm{h}$ - the \textbf{height} of the timetable - the maximal number of events (i.e. arrival or departure of el. conn.) in a city
		\end{itemize}
		
		\begin{table}[h!]
			\centering
			\small
			\begin{tabular}{l|c|c}
			%legend
				\cellcolor{oracle-clr} \textit{\textbf{USP-OR}} & \cellcolor{oracle-clr} \textbf{guaranteed} & \cellcolor{oracle-clr} \parbox{1.8cm}{\textbf{$\bm{\tau = \mathcal{O}(1)}$,\\ $\bm{\gamma \leq \sqrt{n}}$,\\ $\bm{\delta \leq \log n}$}} \\ [2.75ex]
			%data
				\hline
				\cellcolor{oracle-clr} $\bm{prep}$ & $\mathcal{O}(hn^{2} (\log n + \delta))$ & $\mathcal{O}(hn^{2} \log n)$ \\	
				\cellcolor{oracle-clr} $\bm{size}$ & $\mathcal{O}(\tau n^{2} \gamma)$ & $\mathcal{O}(n^{2.5})$ \\
				\cellcolor{oracle-clr} $\bm{qtime}$ & avg. $\mathcal{O}(\tau \gamma)$ & avg. $\mathcal{O}(\sqrt{n})$ \\
				\cellcolor{oracle-clr} $\bm{stretch}$ & $1$ & $1$ \\
			\end{tabular}
			\caption{\label{tab:uspor} The summary of the \textit{USP-OR} algorithm parameters.}
		\end{table}
		
		The value of $\tau$ for our datasets was found to be quite small ($\approx 10$) and just slightly, if at all, increasing with increasing $n$ (see plot~\ref{plot:usp-sncf-size}). Average optimal connection size and the density $\delta$ were as in the second column of table~\ref{tab:uspor} for our timetables. Still, the size of the preprocessed data is too large for practical use, hence the extension of this algorithm, called \textit{USP-OR-A}.
		
		\begin{figure}
			\centering
		    \inputTikZ{./tikzpics/plot_usp_sncf_size}
		    \caption{\label{plot:usp-sncf-size} Changing of $\tau$ with increased number of stations in \textit{sncf} dataset (French railways).}
		\end{figure}
		
	\subsection{\textit{USP-OR-A}}
	
		To decrease the space complexity, in \textit{USP-OR-A} (\textbf{USP} \textbf{or}acle with \textbf{a}ccess nodes) we compute USPs only among cities from a smaller set - called \textbf{access node set} (AN set, denoted $\bm{\mathcal{A}}$). Given such set in timetable $T$, we define for a city $x$ its \textbf{neighbourhood} $\bm{neigh_{\mathcal{A}}(x)}$ as all the cities reachable in $ug_{T}$ \textit{not} via ANs. The access nodes within this neighbourhood are called \textbf{local access nodes} (LANs, $\bm{lan_{\mathcal{A}}(x)}$). We do the same in $\overleftarrow{ug_{T}}$ ($ug_{T}$ with reversed orientation) to get \textbf{back neighbourhood} and \textbf{back LANs}. \\
		
		In the preprocessing we:
		\begin{itemize}
			\item find $\mathcal{A}$ (discussed later)
			\item $\forall x, y \in \mathcal{A}$ compute USPs between $x$ and $y$
			\item $\forall$ cities  $x \not \in \mathcal{A}$ compute $neigh_{\mathcal{A}}(x)$, $bneigh_{\mathcal{A}}(x)$, $lan_{\mathcal{A}}(x)$ and $blan_{\mathcal{A}}(x)$
		\end{itemize}
		\hspace{\fill}
		
		On a query from $x$ to $y$ at time $t$, we will first make a local search in the neighbourhood of $x$ up to $x$'s local access nodes (\textit{local front search} phase). Subsequently, we want to find out the earliest arrival times to each of $y$'s \textit{back} local access nodes. To do this, we take advantage of the pre-computed USPs between access nodes - try out all the pairs $u \in lan(x)$ and $v \in blan(y)$ and expand the stored USPs (\textit{inter-AN search} phase). Finally, we make a local search from each of $y$'s back LANs to $y$, but we run the search \textit{restricted} to $y$'s back neighbourhood (\textit{local back search} phase). See algorithm~\ref{alg:uspora-query} and picture~\ref{fig:uspora} for more clarification.
		
		\color{algcolor}
		\begin{algorithm}[H]
			\color{inalgcolor}
			\caption{\textit{USP-OR-A} query}
			\label{alg:uspora-query}
			\textbf{Input} 
			\begin{itemize}
				\item timetable $T$
				\item OC query $(x, t, y)$
			\end{itemize}
			\textbf{Algorithm}
			\begin{algorithmic}
				\STATE let $lan(x) = x$ if $x \in \mathcal{A}$
				\STATE let $blan(y) = y$ if $y \in \mathcal{A}$
				\STATE \algsec{Local front search}
				\STATE do TD Dijkstra from $x$ at time $t$ up to $lan(x)$
				\IF {$y \in neigh(x)$}
					\STATE $c_{loc}^{*} =$ conn. to $y$ obtained by TD Dijkstra
				\ENDIF
				\STATE $\forall u \in lan(x)$ let $ea(u)$ be the arrival time and $oc(u)$ the conn. to $u$ obtained by TD Dijkstra
				\STATE \algsec{Inter-AN search}
				\FORALL{$v \in blan(y)$}
					\STATE $oc(v) = null$
					\FORALL{$u \in lan(x)$}
						\FORALL{$p \in usps(u, v)$}
							\STATE $c =$ \textit{Expand}$(T, p, ea(u))$
							\STATE $oc(v) =$ better out of $oc(v)$ and $c$
						\ENDFOR
					\ENDFOR
				\ENDFOR
				\STATE $\forall v \in blan(y)$ let $ea(v) = end(oc(v))$
				\STATE \algsec{Local back search}
				\FORALL{$v \in blan(y)$}
					\STATE perform TD Dijkstra from $v$ at time $ea(v)$ to $y$ restricted to $bneigh(y)$
					\STATE $fin(v) =$ the conn. returned by TD Dijkstra	
				\ENDFOR
				\STATE $v^{*} = argmin_{v \in blan(y)} \{end(fin(v))\}$
				\STATE $u^{*} = from(oc(v^{*}))$
				\STATE $c^{*} = oc(u^{*}) . oc(v^{*}) . fin(v^{*})$ \cmt{concat.}
				\STATE output better out of $c_{loc}^{*}$ and $c^{*}$
			\end{algorithmic}
			\textbf{Output}
			\begin{itemize}
				\item optimal connection $c_{(x, t, y)}^{*}$
			\end{itemize}
		\end{algorithm}
		\color{black}
		
		\begin{figure}[h!]
			\begin{center}
				\scriptsize
				\inputTikZ{./tikzpics/uspora}
			\end{center}
			\caption{\label{fig:uspora} Principle of \textit{USP-OR-A} algorithm. The arcs in \textbf{bold} mark areas that will be explored: all nodes in $neigh_{\mathcal{A}}(x)$, USPs between LANs of $x$ and back LANs of $y$ and the back neighbourhood of $y$ (possibly only part of it will be explored, since the local back search goes against the direction in which the back neighbourhood was created).}
		\end{figure}
		
		We will call $\mathcal{A}$ a $\bm{(r_{1}, r_{2}, r_{3})}$ \textbf{AN set} if:
		\begin{itemize}
			\item $|\mathcal{A}| \leq r_{1} \cdot \sqrt{n}$
			\item $avg \; (|neigh_{\mathcal{A}}(x)|)^{2} \leq r_{2} \cdot n$
			\item $|lan_{\mathcal{A}}(x)| \leq r_{3}$
		\end{itemize}
		\hspace{\fill}
		
		If we can manage to find a $(r_{1}, r_{2}, r_{3})$ AN set in time $f(n)$, the parameters of the \textit{USP-OR-A} algorithm are as summarized in table~\ref{tab:uspora-guar}. Table~\ref{tab:uspora-cond} lists the parameters of \textit{USP-OR-A} for timetables with specific properties (as had our datasets) and on which we can find $(r_{1}, r_{2}, r_{3})$ AN set with each $r_{i}$ being a constant (with regard to $n$).
		
		\begin{table}[h!]
			\centering
			\footnotesize
			\begin{tabular}{l|c}
			%legend
				\cellcolor{oracle-clr} \textit{\textbf{USP-OR-A}} & 
				\cellcolor{oracle-clr} \textbf{guaranteed} \\
			%data
				\hline
				\cellcolor{oracle-clr} $\bm{prep}$ & $\mathcal{O}(f(n) + (r_{1} + r_{2}) (\delta + \log n) h n^{1.5})$ \\
				\cellcolor{oracle-clr} $\bm{size}$ & $\mathcal{O}(r_{2} n^{1.5} + r_{1}^{2} \tau_{\mathcal{A}} \gamma_{\mathcal{A}} n)$ \\
				\cellcolor{oracle-clr} $\bm{qtime}$ & avg. $\mathcal{O}(r_{2} r_{3} \sqrt{n} (\log (r_{2}n) + \delta) + r_{3}^{2} \tau_{\mathcal{A}} \gamma_{\mathcal{A}})$ \\
				\cellcolor{oracle-clr} $\bm{stretch}$ & $1$ \\
			\end{tabular}
			\caption{\label{tab:uspora-guar} Guaranteed parameters of the \textit{USP-OR-A} algorithm. $\tau_{\mathcal{A}}$ and $\gamma_{\mathcal{A}}$ are defined just like $\tau$ and $\gamma$, but on the set of cities from $\mathcal{A}$.}
		\end{table}
		
		\begin{table}[h!]
			\centering
			\footnotesize
			\begin{tabular}{l|c}
			%legend
				\cellcolor{oracle-clr} \textit{\textbf{USP-OR-A}} & 
				\cellcolor{oracle-clr} \parbox{3cm}{\textbf{$\bm{\tau, r_{1}, r_{2}, r_{3}}$ const., $\bm{\gamma \leq \sqrt{n}}$, $\bm{\delta \leq \log n}$}} \\ [1.5ex]
			%
				\hline
				\cellcolor{oracle-clr} $\bm{prep}$ & $\mathcal{O}(f(n) + h n^{1.5} \log n)$ \\
				\cellcolor{oracle-clr} $\bm{size}$ & $\mathcal{O}(n^{1.5})$ \\
				\cellcolor{oracle-clr} $\bm{qtime}$ & avg. $\mathcal{O}(\sqrt{n} \log n)$ \\
				\cellcolor{oracle-clr} $\bm{stretch}$ & $1$ \\
			\end{tabular}
			\caption{\label{tab:uspora-cond} Parameters of the \textit{USP-OR-A} algorithm under certain conditions, generally fulfilled by our timetables.}
		\end{table}
		
	\subsection{Selecting access nodes}
	
		The challenge in \textit{USP-OR-A} algorithm therefore comes down to the selection of a good access node set. However, consider the following problem: \textit{minimize $|\mathcal{A}|$ such that $\forall x \not \in \mathcal{A}: |neigh_{\mathcal{A}}(x)| \leq \sqrt{n}$}. We call this the problem of the optimal AN set.
		
		\begin{theorem}
			The problem of the optimal AN set is NP-complete
		\end{theorem}
		\begin{proof}
			We will provide a sketch of the proof, which in full extend would be available in~\cite{dottg13}. We will make a reduction of the \textit{min-set cover} problem to the problem of optimal AN set. \\
			
			\noindent Consider an instance of the min-set cover problem:
			\begin{itemize}
				\item A universe $U = \{1, 2, ..., m\}$
				\item $k$ subsets of $U$: $S_{i} \subseteq U \; i = \{1, 2, ..., k\}$ whose union is $U$: $\bigcup\limits_{1 \leq i \leq k} S_{i} = U$
			\end{itemize}
			\hspace*{\fill}
			
			\noindent Denote $\mathcal{S} = \{S_{i}| \; 1 \leq i \leq k\}$. The task is to choose the smallest subset $\mathcal{S}^{*}$ of $\mathcal{S}$ that still covers the universe ($\bigcup\limits_{S_{i} \in \mathcal{S}^{*}} S_{i} = U$). For each $j \in U$, we will make a complete graph of $\beta_{j}$ vertices (the value of $\beta_{j}$ will be discussed later) named $m_{j}$ and for each set $S_{i}$ we make a vertex $s_{i}$ and vertex $s_{i}'$. We now connect all vertices of $m_{j}$ to $s_{i} \iff j \in S_{i}$. Finally, for we connect $s_{i}$ to $s_{i}'$, $1 \leq i \leq k$. \\
			 
			\noindent \textbf{Example}. Let $m = 10$ (thus $U = \{1, 2, ..., 10\}$) and $k = 13$:
			\begin{itemize}
				\item $S_{1} = \{1, 3, 10\}$
			 	\item $S_{2} = \{1, 2\}$
			 	\item ...
			 	\item $S_{13} = \{2, 3, 10\}$
			\end{itemize}
			\hspace*{\fill}
			 
			\noindent For this instance of min set-cover, we construct the graph depicted on picture~\ref{fig:reduction}. \\
			 
			\begin{figure}[h!]
				\begin{center}
					\inputTikZ{./tikzpics/reduction}
				\end{center}
				\caption{\label{fig:reduction} In $m_{i}$, there are actually complete graphs of $\beta_{i}$ vertices (as shown for $m_{1}$). \textbf{Thick} arcs represent arcs from all the vertices of respective $m_{i}$. The $s_{i}$ vertices are connected to their $s_{i}'$ versions. If e.g. $s_{1}$ is selected as an access node, $s_{1}'$ is no longer part of any neighbourhood.}
			\end{figure}
			
			\noindent Define $\alpha_{i}$ to be the number of sets $S_{j}$ that contain $i$: $\alpha_{i} = |\{S_{j} \in \mathcal{S}| \; i \in S_{j}\}|$ and assume the constructed graph has $n$ vertices. We want the $\beta_{i}$ to satisfy $\beta_{i} \geq 2$ and $\beta_{i} + 2\alpha_{i} - 1 \leq \sqrt{n}$ but $\beta_{i} + 2\alpha_{i} > \sqrt{n}$. The last two inequalities would mean that if at least one $s_{j}$ connected to $m_{i}$ is chosen as an access node, the neighbourhood for nodes in $m_{i}$ will be still $\leq$ $\sqrt{n}$, but if none of them is chosen, the neighbourhood will be just over $\sqrt{n}$. We leave out the details of the construction at this place. \\
			
			Now consider an optimal AN set which contains a vertex from within some $m_{i}$. If this is the case, \textbf{either} some $s_{j}$ to which $m_{i}$ is connected is selected as AN, \textbf{or} \textit{all} vertices from $m_{i}$ are access nodes \textbf{or} the neighbourhood is too large. Keep in mind that the local access nodes are also part of neighbourhoods, so unless we select for AN some of the $s_{j}$ that $m_{i}$ is connected to, the neighbourhood of any non-access node in $m_{i}$ will be too large. As there are at least two nodes in every $m_{i}$, it is more efficient to select some $s_{j}$ rather then select all nodes in $m_{i}$. Thus when it comes to selecting ANs \textit{it is worth to consider only vertices $s_{j}$}. \\
			
			From this point on, it is easy to see that it is optimal to select those $s_{j}$ that correspond to the optimal solution of min-set cover. The reason is that each of the $m_{i}$ will be connected to at least one access node $s_{j}$ and will thus have neighbourhood size $\leq \sqrt{n}$, while the number of selected access nodes will be optimal. \\
		\end{proof}
		
		We have therefore approached selection a good AN set heuristically. We iteratively selected ANs by their importance until the average square of the neighbourhood size was not $\leq \sqrt{n}$ (i.e. the $r_{1}$ parameter of the set was $\leq 1$). To estimate the city's importance, we tried three values:
		\begin{itemize}
			\item Degree of the node in $ug_{T}$
			\item Betweenness centrality~\cite{centrality01} of the node in $ug_{T}$
			\item Our own value called \textbf{potential}, high for those nodes that are good local separators in $ug_{T}$
		\end{itemize}
		\hspace{\fill}
		
		Our algorithm, called \textit{Locsep}, computes the city's potential in the following way: we explore an area $\bm{A_{x}}$ of $\sqrt{n}$ nearest cities around $x$. We do this in an underlying graph with no orientation and no weights. Next we get the front and back neighbourhoods of $x$ within $A_{x}$ ($\bm{fn(x)} = neigh(x) \cap A_{x}$, $\bm{bn(x)} = bneigh(x) \cap A_{x}$). For a set of access nodes $\mathcal{A}$, let us call a path $p$ in $ug_{T}$ \textbf{access-free} if it does not contain a node from $\mathcal{A}$. Now as long as $x$ is not in $\mathcal{A}$, there is a guarantee that for every pair $u \in bn(x)$ and $v \in fn(x)$ there is an access-free path from $u$ to $v$ within $A_{x}$. Our interest is how this will change after the selection of $x$. \\
		
		Let $bneigh_{i} = bneigh(b_{i}) \cap A_{x}$ for each arc $(b_{i}, x) \in ug_{T}$. We run a restricted (to $A_{x} \setminus \{x\}$) search from each $bneigh_{i}$ during which we explore $e_{i}$ vertices in $fn(x)$. This is going to contribute up to $e_{i}|bneigh_{i}|$ to $x$'s potential, depending on if the cities in $bneigh_{i}$ actually have large neighbourhoods (and thus selecting $x$ would help). More details regarding the \textit{Locsep} algorithm will be in~\cite{dottg13}. For illustration of the principle of computing the potential, see picture~\ref{fig:locsep}. Also, see plot~\ref{plot:locsep-sncf-size} for comparison of \textit{Locsep} algorithm to the approach of choosing ANs based on high degree/BC values.
		
		\begin{figure}[h!]
			\begin{center}
				\inputTikZ{./tikzpics/locsep}
			\end{center}
			\caption{\label{fig:locsep} The principle of computing potentials in Locsep algorithm. We explored an area of $\sqrt{n}$ nearest cities (in terms of hops) around $x$. Little \textcolor{purple}{squares} are nodes from $neigh(x)$ and \textcolor{cyan}{diamonds} are part of $bneigh(x)$. The highlighted area represents the back neighbourhood for node $b_{2}$. From its nodes we run a forward search (the \textbf{thick} arcs). Nodes from the $neigh(x)$ that were not explored in this search can only be reached via $x$ itself and contribute to $x$'s potential.}
		\end{figure}
		
		\begin{figure}[h!]
            \begin{center}
                \inputTikZ{./tikzpics/plot_locsep_sncf_size}
            \end{center}
            \vspace{-0.3cm}
            \caption{\label{plot:locsep-sncf-size} The necessary size of $\mathcal{A}$ when selecting ANs based on degree, BC or \textit{Locsep} potential in \textit{sncf} dataset ($|\mathcal{A}| = r_{1} \sqrt{n} \approx r_{1} 51$). Ideal situation would be a constant or non-increasing value, to which \textit{Locsep} comes closest.}
		\end{figure}
		
\section{Performance and comparisons}

	We have run tests on the datasets described in table~\ref{table:tt_mainpr}. We compared the query time of \textit{USP-OR}, \textit{USP-OR-A} with \textit{Locsep} and time-dependent Dijkstra's algorithm using priority queues based on Fibonacci heaps (\textit{TD Dijkstra} for short). The average query times for these algorithms (at our timetables) are theoretically determined as:
	\begin{itemize}
		\item $\mathcal{O}(\sqrt{n})$ for \textit{USP-OR}
		\item $\mathcal{O}(\sqrt{n} \log n)$ for \textit{USP-OR-A} with \textit{Locsep}
		\item $\mathcal{O}(n \log n)$ for \textit{TD Dijkstra}~\footnote{Actually, the complexity of time-dependent Dijkstra's algorithm with Fibonacci heap priority queues is $\mathcal{O}(m + n \log n)$~\cite{sommerthesis10}, but in our timetables $m \leq n \log n$}
	\end{itemize}
	\hspace{\fill}
	
	For the dataset of French railways (\textit{sncf}) we measured how the query times evolve with increased $n$ (see plot~\ref{plot:usporall-sncf-size}) and for the dataset of Slovak railways (\textit{zsr}) we measured the evolution of query times with respect to increased time range (plot~\ref{plot:usporall-zsr-trange}). Finally, for all of our timetables, we measured the speed-up against TD Dijkstra, i.e. how many times faster were our algorithms then TD Dijkstra. For the speed-ups, refer to table~\ref{tab:speedup}. \\
	
	\begin{table}[h!]
		\centering
		\footnotesize
		\begin{tabular}{c|c|c|c}
		%legend
			\rowcolor{tablehead}
			\textbf{Name} & \textbf{Description} & \textbf{Cities} & \textbf{UG arcs} \\
		%data
			\hline
			\textit{cpru} & Reg. bus (SVK - RK) & 871 & 2415 \\
			\textit{cpza} & Reg. bus (SVK - ZA) & 1108 & 2778 \\
			\textit{montr} & Public tr. (Montreal) & 217 & 349  \\
			\textit{sncf} & Railways (FRA) & 2646 & 7994 \\
			\textit{sncf-inter} & Inter-city rail. (FRA) & 366 & 901 \\
			\textit{sncf-ter} & Regional rail. (FRA) & 2637 & 7647 \\
			\textit{zsr} & Railways (SVK) & 233 & 588 \\
		\end{tabular}
		\caption{\label{table:tt_mainpr} Datasets used for testing.}
		\normalsize
	\end{table}	

	\begin{figure}[h!]
		\begin{center}
        	\inputTikZ{./tikzpics/plot_usporall_sncf_size}
		\end{center}
		\caption{\label{plot:usporall-sncf-size} Query times (in sec., 25000 queries). \textit{USP-OR-A} + \textit{Locsep} vs. \textit{USP-OR} vs. \textit{TD Dijkstra} on \textit{sncf} dataset. Changing $n$.}
	\end{figure}
	\begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/plot_usporall_zsr_trange}
		\end{center}
		\caption{\label{plot:usporall-zsr-trange} Query times (in sec., 25000 queries). \textit{USP-OR-A} + \textit{Locsep} vs. \textit{USP-OR} vs. \textit{TD Dijkstra} on \textit{zsr} dataset. Changing time range.}
	\end{figure}
	
	\begin{table}[h!]
        \centering
		\begin{tabular}{c|c|c}
		%legend
            \rowcolor{tablehead}
            \textbf{Name} & \textit{\textbf{USP-OR}} & \textit{\textbf{USP-OR-A}} \\
		%data
			\hline
			\textit{cpru} & 14.5 & 1.7 \\
			\textit{cpza} & 14.3 & 1.7 \\
			\textit{montr} & 8.8 & 1.5 \\
			\textit{sncf} & 64.8 & 5.4 \\
			\textit{sncf-inter} & 27.0 & 3.6 \\
			\textit{sncf-ter} & 78.3 & 6.3 \\
			\textit{zsr} (daily) & 19.3 & 2.14 \\
		\end{tabular}
		\caption{\label{tab:speedup} Speed-up of \textit{USP-OR} and \textit{USP-OR-A} with \textit{Locsep}.}
	\end{table}
	
	As for the size of the preprocessed data, we compared \textit{USP-OR} to \textit{USP-OR-A} with \textit{Locsep} in a similar way we did for the query times: in plots~\ref{plot:usporalls-sncf-size},~\ref{plot:usporalls-zsr-trange} there are the actual sizes (in MB) of the data preprocessed by our algorithms and the amount of memory needed to actually represent the timetable in memory (as a time-dependent graph~\cite{tdroute09}). In table~\ref{tab:size} we provided the ratios specifying how many times more MB was pre-computed then the memory needed for the time-dependent graph. Again we remind the theoretically determined sizes of preprocessed data for our algorithms (and on our timetables):
	\begin{itemize}
		\item $\mathcal{O}(n^{2.5})$ for \textit{USP-OR}
		\item $\mathcal{O}(n^{1.5})$ for \textit{USP-OR-A} with \textit{Locsep}
	\end{itemize}
	\hspace{\fill}
	
	\begin{figure}[h!]
		\begin{center}
        	\inputTikZ{./tikzpics/plot_usporalls_sncf_size}
		\end{center}
		\caption{\label{plot:usporalls-sncf-size} Size (in MB) of preprocessed data. \textit{USP-OR-A} + \textit{Locsep} vs. \textit{USP-OR} vs. \textit{TD Dijkstra} on \textit{sncf} dataset. Changing $n$.}
	\end{figure}
	\begin{figure}[h!]
		\begin{center}
			\inputTikZ{./tikzpics/plot_usporalls_zsr_trange}
		\end{center}
		\caption{\label{plot:usporalls-zsr-trange} Size (in MB) of preprocessed data. \textit{USP-OR-A} + \textit{Locsep} vs. \textit{USP-OR} vs. \textit{TD Dijkstra} on \textit{zsr} dataset. Changing time range.}
	\end{figure}	
	
	\begin{table}[h!]
        \centering
		\begin{tabular}{c|c|c}
		%legend
            \rowcolor{tablehead}
            \textbf{Name} & \textit{\textbf{USP-OR}} & \textit{\textbf{USP-OR-A}} \\
		%data
			\hline
			\textit{cpru} & 396.7 & 3.0 \\
			\textit{cpza} & 265.1 & 3.5 \\
			\textit{montr} & 61.1 & 1.3 \\
			\textit{sncf} & 106.2 & 4.0 \\
			\textit{sncf-inter} & 30.3 & 1.5 \\
			\textit{sncf-ter} & 87.4 & 2.6 \\
			\textit{zsr} (daily) & 60.8 & 2.2 \\
		\end{tabular}
		\caption{\label{tab:size} The ratio $\frac{\text{size of TD graph}}{\text{preprocessed size}}$ for \textit{USP-OR} and \textit{USP-OR-A} with \textit{Locsep}.}
	\end{table}

\section{Conclusion}

	In~\cite{engtimeexp09} the authors have considered the optimal connection problem in time-expanded graphs, and achieved speed-ups of up to 56 against Dijkstra's algorithm in railway timetables with about 30000 stations. \\

	We approached the problem through the time-\textit{dependent} model and have developed exact methods to considerably speed-up the query time for optimal connections in timetables compared to the time-dependent Dijkstra's algorithm using Fibonacci heaps as priority queues (running in $\mathcal{O}(m + n \log n)$). Our first algorithm - \textit{USP-OR} - achieves speed-ups of up to 65 on our largest dataset representing French railways (2500+ stations). However, it does so at the cost of high space consumption, requiring more that 100 times the space that is needed to represent the timetable itself. Theoretically, for real-world timetables (that usually have certain properties), this algorithm has the space complexity $\mathcal{O}(n^{2.5})$ and the average query time $\mathcal{O}(\sqrt{n})$. \\
	
	Our second algorithm called \textit{USP-OR-A} is still 6 times faster then time-dependent Dijkstra's algorithm and at the same time, for all of our datasets it requires space up to 4 times the space needed to represent the timetable. We believe the speed-up of \textit{USP-OR-A} against Dijkstra's algorithm can be even higher for bigger timetables, since its query time is theoretically determined as $\mathcal{O}(\sqrt{n} \log n)$, while the algorithm can handle much bigger datasets for its space complexity is essentially $\mathcal{O}(n^{1.5})$. \\

\section*{Acknowledgments}
	I would like to thank very much to my supervisor Rastislav Královič for valuable remarks, useful advices and consultations that helped me stay on the right path during my work on this project.

%---------------------------------------------------------------------
%   BACKMATTER  ------------------------------------------------------
%---------------------------------------------------------------------
    %\backmatter

    %---------------------------------------------------------------------
    %   bibliography
    %---------------------------------------------------------------------



	\nocite{*}
	\bibliographystyle{apalike}
	\bibliography{bibl}
\end{document} 